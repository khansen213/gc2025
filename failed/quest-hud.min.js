/* quest-hud.min.js — Simpler + Debug-first dialog + HUD
   - Autoplay correct section dialog AFTER confirmed goToIndex success (once per section per session)
   - Gate dialog plays whenever the gate shows (even after reload)
   - Uses window.currentIndex when available
   - Restores Rules Ack persistence
   - Very verbose console logs with [HUD]
*/
(()=>{

/* ---------------- Basics & logger ---------------- */
const $  = (sel, root=document)=>root.querySelector(sel);
const $$ = (sel, root=document)=>Array.from(root.querySelectorAll(sel));
const raf = (fn)=>requestAnimationFrame(fn);
const log = (...a)=>console.log('[HUD]', ...a);

/* ---------------- Small CSS we need ---------------- */
(function ensureStyles(){
  const id='hud-mini-styles';
  if(document.getElementById(id)) return;
  const s=document.createElement('style'); s.id=id;
  s.textContent = `
    #hp-hud{position:fixed;top:12px;right:12px;z-index:90;display:flex;gap:10px;align-items:center;
      background:rgba(18,18,18,.75);backdrop-filter:blur(5px);border:2px solid rgba(255,255,255,.18);border-radius:14px;
      padding:8px 10px;box-shadow:0 8px 18px rgba(0,0,0,.35)}
    #hp-replay{background:#FFD74A;color:#121212;border:0;border-radius:999px;width:36px;height:36px;font-weight:900;cursor:pointer}
    #hp-hud.replay-front{z-index:9999}
    .popshake{animation:popshake .5s both}
    @keyframes popshake{0%{transform:translateY(0) scale(1)}25%{transform:translateY(-3px) scale(1.08)}50%{transform:translateY(0) rotate(-4deg)}75%{transform:translateY(-1px) rotate(4deg)}100%{transform:translateY(0) scale(1)}}
    #hp-replay.replay-cue-in{animation:replayIn .24s ease-out}
    @keyframes replayIn{from{transform:scale(.85);opacity:.2}to{transform:scale(1);opacity:1}}
    #hp-replay.replay-press-demo{animation:replayPress .9s cubic-bezier(.2,.6,.3,1)}
    @keyframes replayPress{0%{transform:scale(1)}30%{transform:scale(1.12)}60%{transform:scale(.98)}100%{transform:scale(1)}}
    #dlg-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.45);display:none;place-items:center;z-index:120}
    #dlg-backdrop.show{display:grid}
    #dlg-box{background:#1b1330;border:2px solid #5f4b8a;border-radius:14px;width:min(92vw,920px);padding:12px;color:#F7F5FF;box-shadow:0 12px 36px rgba(0,0,0,.45)}
    #dlg-row{display:grid;grid-template-columns:auto 1fr auto;gap:10px;align-items:center}
    #dlg-emoji{font-size:28px}
    #dlg-text{min-height:56px;font-size:18px;line-height:1.4}
    #dlg-advance{background:#FFD74A;color:#121212;border:0;border-radius:10px;width:40px;height:40px;font-weight:900;cursor:pointer}
    #dlg-emoji.speaking{animation:talky .5s ease-in-out infinite}
    @keyframes talky{0%,100%{transform:translateY(0)}50%{transform:translateY(-2px)}}
  `;
  document.head.appendChild(s);
})();

/* ---------------- HUD + replay cue ---------------- */
function attachEmojiFX(root=document){
  root.addEventListener('mouseenter', e=>{
    const t = e.target.closest?.('[data-emoji="true"]'); if(!t) return;
    if(t.dataset.animating==='1') return; t.dataset.animating='1'; t.classList.add('popshake');
  }, true);
  root.addEventListener('click', e=>{
    const t = e.target.closest?.('[data-emoji="true"]'); if(!t) return;
    if(t.dataset.animating==='1') return; t.dataset.animating='1'; t.classList.add('popshake');
  }, true);
  root.addEventListener('animationend', e=>{
    const t = e.target; if(t.classList.contains('popshake')){ t.classList.remove('popshake'); t.dataset.animating=''; }
  }, true);
}
function ensureHPHud(){
  if($('#hp-hud')) return;
  const hud=document.createElement('div'); hud.id='hp-hud';
  hud.innerHTML=`<span class="emoji" data-emoji="true" aria-hidden="true">🐉</span><button id="hp-replay" aria-label="Replay dialog">▶</button>`;
  document.body.prepend(hud);
  attachEmojiFX(hud);
  $('#hp-replay').addEventListener('click', ()=>playDialogFor(currentSectionId(), true));
  log('HUD ready.');
}
function cueReplayHint(){
  const btn = $('#hp-replay'), hud = $('#hp-hud');
  if(!btn||!hud) return;
  btn.classList.remove('replay-cue-in','replay-press-demo'); void btn.offsetWidth;
  btn.classList.add('replay-cue-in'); requestAnimationFrame(()=>btn.classList.add('replay-press-demo'));
  hud.classList.add('replay-front'); setTimeout(()=>hud.classList.remove('replay-front'), 2000);
  log('Replay cue animated.');
}

/* ---------------- Rules Acknowledge (persist) ---------------- */
const RULES_KEY='gc_rules_ack';
function ensureRulesAck(){
  const rulesCard = $('#rules-card') || $('#sec-rules .card');
  if(!rulesCard) { log('Rules card not found (ok if not on page yet).'); return; }
  let box = $('#rules-ok');
  if(!box){
    // in case your HTML didn’t include it for some reason, add a small one
    const wrap = document.createElement('div');
    wrap.style.marginTop='12px';
    wrap.innerHTML = `<label style="display:flex;gap:10px;align-items:center"><input id="rules-ok" type="checkbox"> <strong>I read and understand the rules.</strong></label>`;
    rulesCard.appendChild(wrap);
    box = wrap.querySelector('#rules-ok');
  }
  const persisted = localStorage.getItem(RULES_KEY)==='true';
  box.checked = persisted;
  if(!box._wired){
    box.addEventListener('change', ()=>{ localStorage.setItem(RULES_KEY, box.checked?'true':'false'); log('Rules ack set:', box.checked); });
    box._wired=true;
  }
  log('Rules ack ensured. checked=', box.checked);
}

/* ---------------- Dialog scripts ---------------- */
const DIALOG_SCRIPTS = {
  'sec-gate': [
    { emoji:'🧙‍♂️', voicePrefs:['Google UK English Male','Daniel','Alex'], text:'Halt!' },
    { emoji:'🧙‍♂️', voicePrefs:['Google UK English Male','Daniel','Alex'], text:'Who goes there?' },
    { emoji:'🧙‍♂️', voicePrefs:['Google UK English Male','Daniel','Alex'], text:'Continue the story? Enter your PIN provided by the Master.' },
  ],
  'sec-intro': [
    { emoji:'🧙‍♂️', voicePrefs:['Google UK English Male','Daniel','Alex'], text:'If you need to hear any dialog for a second time, just press the play button in the top right of the screen, and it will play again for you.' },
    { emoji:'🐉',    voicePrefs:['Google UK English Male','Daniel','Alex'], text:'I am no villain. Yet the Wizard binds me with his sigils. My wings carry fire against my will.' },
    { emoji:'🧙‍♂️', voicePrefs:['Google UK English Male','Daniel','Alex'], text:'Behold, mortals. I am Spooklek of Saurcrez. From the void I come to claim the scrolls of your magic.' },
    { emoji:'🧙‍♂️', voicePrefs:['Google UK English Male','Daniel','Alex'], text:'Yielding this dragon, I will take what is mine!' },
    { emoji:'🧚‍♀️', voicePrefs:['Google US English','Samantha','Victoria'], text:'Your greed ends here, sorcerer. These scrolls are the lifeblood of our kingdom. Traveler, speak your alias and true name, and we might trust you.' },
  ],
  'sec-what': [
    { emoji:'🧚‍♀️', voicePrefs:['Google US English','Samantha','Victoria'], text:'Five sessions, five works of originality. One must be a freebie — a craft of your own choosing.' },
    { emoji:'🧙‍♂️', voicePrefs:['Google UK English Male','Daniel','Alex'], text:'Create them if you must. In the end, all scrolls will be mine to command.' },
    { emoji:'🐉',    voicePrefs:['Google UK English Male','Daniel','Alex'], text:'I am forced to bear his threats between realms. Each creation swells the hoard he covets.' },
  ],
  'sec-rules': [
    { emoji:'🧚‍♀️', voicePrefs:['Google US English','Samantha','Victoria'], text:'Hear the rules of fairness. Swear to them and check the vow, or the challenge cannot continue.' },
    { emoji:'🧙‍♂️', voicePrefs:['Google UK English Male','Daniel','Alex'], text:'Break them and watch your hard-won points turn to dust.' },
    { emoji:'🐉',    voicePrefs:['Google UK English Male','Daniel','Alex'], text:'The sigils lash at me when deceit is near. He forces me to strike, though my heart is not in it.' },
  ],
  'sec-overview': [
    { emoji:'🧚‍♀️', voicePrefs:['Google US English','Samantha','Victoria'], text:'Choose your crafts with care — word searches, crosswords, notes, puzzles, and the destined freebie.' },
    { emoji:'🧙‍♂️', voicePrefs:['Google UK English Male','Daniel','Alex'], text:'Sameness is weakness. Your choices reveal patterns I can exploit.' },
    { emoji:'🐉',    voicePrefs:['Google UK English Male','Daniel','Alex'], text:'Each choice is another scroll placed upon the scales.' },
  ],
  'sec-grid': [
    { emoji:'🧚‍♀️', voicePrefs:['Google US English','Samantha','Victoria'], text:'Now set your sessions in order. Every scroll must take its rightful place.' },
    { emoji:'🧙‍♂️', voicePrefs:['Google UK English Male','Daniel','Alex'], text:'Arrange them poorly and your scrolls fall into my grasp.' },
    { emoji:'🐉',    voicePrefs:['Google UK English Male','Daniel','Alex'], text:'I feel the tug of battle in each placement. Free me through wisdom, not folly.' },
  ],
  'sec-details': [
    { emoji:'🧚‍♀️', voicePrefs:['Google US English','Samantha','Victoria'], text:'Pour detail into your works: themes, counts, difficulties, and plans.' },
    { emoji:'🧙‍♂️', voicePrefs:['Google UK English Male','Daniel','Alex'], text:'The more you reveal, the easier to bind them to my will.' },
    { emoji:'🐉',    voicePrefs:['Google UK English Male','Daniel','Alex'], text:'Yet these same details chip at my chains. Complete them and I may be freed.' },
  ],
  'sec-submit': [
    { emoji:'🧚‍♀️', voicePrefs:['Google US English','Samantha','Victoria'], text:'Traveler, sign with your initial. Seal your legend. Then print your proof and deliver it.' },
    { emoji:'🧙‍♂️', voicePrefs:['Google UK English Male','Daniel','Alex'], text:'At the seal, I shall seize all that you have written! The fairies’ knowledge will be mine.' },
    { emoji:'🐉',    voicePrefs:['Google UK English Male','Daniel','Alex'], text:'No… the sigils crack with your originality. My chains shatter!' },
    { emoji:'🧚‍♀️', voicePrefs:['Google US English','Samantha','Victoria'], text:'Stand, Dragon. Guard, not destroy.' },
    { emoji:'🐉',    voicePrefs:['Google UK English Male','Daniel','Alex'], text:'I cast his staff into the abyss! The fire is no longer his.' },
    { emoji:'🧙‍♂️', voicePrefs:['Google UK English Male','Daniel','Alex'], text:'No! Your novelty unravels my runes! This cannot—Aaaaagh!' },
    { emoji:'🧚‍♀️', voicePrefs:['Google US English','Samantha','Victoria'], text:'The Wizard is undone. The Dragon is free. The scrolls of knowledge are safe. Our kingdom endures.' },
  ],
};

/* ---------------- Dialog engine (small + logs) ---------------- */
let dlg = {
  backdrop:null, box:null, emoji:null, text:null, btn:null,
  typing:false, speaking:false, holdSpeed:false,
  charIndex:0, lineIndex:0, lines:[],
  voices:[], voiceReady:false, ttsUtter:null, skipArmed:false,
};
function ensureDialogUI(){
  if($('#dlg-backdrop')) return;
  const back=document.createElement('div'); back.id='dlg-backdrop';
  const box=document.createElement('div'); box.id='dlg-box'; box.setAttribute('role','dialog'); box.setAttribute('aria-modal','true');
  box.innerHTML=`
    <div id="dlg-row">
      <div id="dlg-emoji" class="emoji" data-emoji="true" aria-hidden="true">🧙‍♂️</div>
      <div id="dlg-text" aria-live="polite"></div>
      <button id="dlg-advance" aria-label="Advance">▶</button>
    </div>`;
  back.appendChild(box);
  document.body.appendChild(back);
  attachEmojiFX(back);
  dlg.backdrop=back; dlg.box=box;
  dlg.emoji=$('#dlg-emoji',box); dlg.text=$('#dlg-text',box); dlg.btn=$('#dlg-advance',box);
  dlg.btn.addEventListener('click', onAdvanceInput);
  log('Dialog UI created.');
}
function openDialog(){ ensureDialogUI(); dlg.backdrop.classList.add('show'); log('Dialog open.'); }
function closeDialog(){ if(!dlg.backdrop) return; dlg.backdrop.classList.remove('show'); cancelTTS(); log('Dialog closed.'); }
function loadVoicesOnce(){
  if(dlg.voiceReady) return;
  const grab=()=>{ dlg.voices=speechSynthesis.getVoices()||[]; dlg.voiceReady=true; log('Voices:', dlg.voices.map(v=>v.name)); };
  if('speechSynthesis' in window){
    speechSynthesis.onvoiceschanged=grab; setTimeout(()=>{ if(!dlg.voiceReady) grab(); }, 300);
  }else{ dlg.voiceReady=true; log('speechSynthesis not supported'); }
}
function pickVoice(prefs){ if(!('speechSynthesis' in window)) return null; const v=speechSynthesis.getVoices(); if(!v?.length) return null; const by=n=>v.find(x=>x.name.toLowerCase()===String(n).toLowerCase()); for(const p of (prefs||[])){ const f=by(p); if(f) return f; } return v[0]; }
function cancelTTS(){ try{ if('speechSynthesis' in window){ if(dlg.ttsUtter){ dlg.ttsUtter.onend=null; dlg.ttsUtter.onerror=null; } if(speechSynthesis.speaking) speechSynthesis.cancel(); } }catch{} dlg.speaking=false; dlg.emoji?.classList.remove('speaking'); log('TTS canceled'); }
function typeLine(full){
  // TTS starts immediately with typing
  try{ cancelTTS(); speak(full); }catch{}
  dlg.typing=true; dlg.charIndex=0; dlg.text.textContent='';
  const stepBase=22;
  const tick=()=>{
    if(!dlg.typing) return;
    const step = Math.max(1, dlg.holdSpeed?2:1);
    dlg.charIndex += step;
    dlg.text.textContent = full.slice(0, dlg.charIndex);
    if(dlg.charIndex>=full.length){ dlg.typing=false; return; }
    setTimeout(()=>raf(tick), dlg.holdSpeed? stepBase/2 : stepBase);
  }; tick();

  if(/press the play button/i.test(full)) cueReplayHint();
  log('Typing:', full);
}
function speak(text){
  if(!('speechSynthesis' in window)) return;
  const meta=dlg.lines[dlg.lineIndex]||{};
  const u = new SpeechSynthesisUtterance(text);
  const v = pickVoice(meta.voicePrefs);
  if(v) u.voice=v;
  u.onend=()=>{ dlg.speaking=false; dlg.emoji?.classList.remove('speaking'); dlg.skipArmed=true; log('TTS end'); };
  u.onerror=u.onend;
  dlg.speaking=true; dlg.emoji?.classList.add('speaking');
  dlg.ttsUtter=u;
  try{ speechSynthesis.speak(u); log('TTS speak:', v?.name||'(default)'); }catch{ dlg.speaking=false; dlg.emoji?.classList.remove('speaking'); }
}
function onAdvanceInput(){
  if(dlg.typing){ const full=(dlg.lines[dlg.lineIndex]?.text)||''; dlg.typing=false; dlg.text.textContent=full; cancelTTS(); dlg.skipArmed=true; log('Advance: finish typing + arm'); return; }
  if(dlg.speaking){ cancelTTS(); dlg.skipArmed=true; log('Advance: cancel speaking + arm'); return; }
  dlg.skipArmed=false; advanceLine();
}
function advanceLine(){
  dlg.lineIndex++;
  if(dlg.lineIndex>=dlg.lines.length){ closeDialog(); log('Advance: done all lines'); return; }
  const line=dlg.lines[dlg.lineIndex];
  dlg.emoji.textContent=line.emoji||'🧙‍♂️';
  dlg.text.textContent='';
  typeLine(String(line.text||''));
  log('Advance: line', dlg.lineIndex+1, '/', dlg.lines.length);
}
function playDialogFor(sectionId, force=false){
  if(!sectionId){ log('playDialogFor: no sectionId'); return; }
  const key=`dlg_ran_${sectionId}`;
  if(!force && sessionStorage.getItem(key)==='1'){ log('playDialogFor: skip (already in session):', sectionId); return; }
  const lines=DIALOG_SCRIPTS[sectionId];
  if(!lines?.length){ log('playDialogFor: no lines for', sectionId); return; }
  ensureDialogUI(); loadVoicesOnce();
  cancelTTS();
  dlg.lines=lines; dlg.lineIndex=-1;
  openDialog(); advanceLine();
  sessionStorage.setItem(key,'1');
  log('playDialogFor: START', sectionId, 'force=', !!force);
}

/* ---------------- Section helpers (use currentIndex if present) ---------------- */
function sections(){ return $$('#scroller > section'); }
function sectionIdByIndex(i){ return sections()[i]?.id || null; }
function currentSectionId(){
  // Prefer your app’s currentIndex
  if(typeof window.currentIndex==='number'){ const id=sectionIdByIndex(window.currentIndex); log('currentSectionId via currentIndex:', window.currentIndex, '→', id); return id; }
  // Fallback: compute closest to scrollTop
  const SCROLLER = $('#scroller') || window;
  const st = (SCROLLER===window)? window.scrollY : SCROLLER.scrollTop;
  const base = (SCROLLER===window)? 0 : SCROLLER.getBoundingClientRect().top;
  let best=null, dist=1e9;
  for(const s of sections()){
    const d=Math.abs(s.getBoundingClientRect().top - base + ((SCROLLER===window)? 0 : SCROLLER.scrollTop) - st);
    if(d<dist){ dist=d; best=s; }
  }
  const id = best?.id || null; log('currentSectionId via scroll:', id); return id;
}

/* ---------------- Gate detection + patch ---------------- */
function gateElement(){ return document.getElementById('sec-gate'); }
function isGateVisible(){
  const g = gateElement(); if(!g) return false;
  const style = window.getComputedStyle(g);
  const visible = style.display!=='none';
  log('isGateVisible =', visible);
  return visible;
}
function clearGatePlayed(){ try{ sessionStorage.removeItem('dlg_ran_sec-gate'); log('Cleared gate dialog flag'); }catch{} }

function installGatePatches(){
  const show = window.showGate;
  const hide = window.hideGate;

  // Patch showGate → force play gate dialog (fresh) every time the overlay appears
  if(typeof show === 'function' && !show.__hudPatched){
    window.showGate = function(){
      log('showGate() patched: calling original…');
      const r = show.apply(this, arguments);
      clearGatePlayed();
      // Gate is visible now → play gate dialog even if it ran earlier this session
      raf(()=>{ if(isGateVisible()) playDialogFor('sec-gate', /*force*/true); });
      return r;
    };
    window.showGate.__hudPatched = true;
    log('showGate patched.');
  }else{
    log('showGate not found (ok if not needed).');
  }

  // Patch hideGate → when overlay disappears, auto-play the first real section if not yet played
  if(typeof hide === 'function' && !hide.__hudPatched){
    window.hideGate = function(){
      log('hideGate() patched: calling original…');
      const r = hide.apply(this, arguments);
      raf(()=>setTimeout(()=>{
        const id = currentSectionId();
        log('After hideGate, visible section is', id);
        if(id && id!=='sec-gate') playDialogFor(id, /*force*/false);
      }, 0));
      return r;
    };
    window.hideGate.__hudPatched = true;
    log('hideGate patched.');
  }else{
    log('hideGate not found (ok).');
  }

  // If the gate is already visible on load, clear flag & play immediately
  raf(()=>{ if(isGateVisible()){ clearGatePlayed(); playDialogFor('sec-gate', true); }});
}

/* ---------------- goToIndex patch (autoplay after confirmed nav) ---------------- */
function installGoToIndexPatch(){
  const orig = window.goToIndex;
  if(typeof orig!=='function'){ log('goToIndex not ready yet.'); return false; }
  if(orig.__dlgPatched){ log('goToIndex already patched.'); return true; }

  window.goToIndex = function(i, cause){
    const before = currentSectionId();
    const target = sectionIdByIndex(i);
    log('goToIndex(patched) called:', {i, cause, before, target});
    const ret = orig.apply(this, arguments);

    // Confirm we actually landed. Prefer currentIndex, fall back to scroll check.
    raf(()=>setTimeout(()=>{
      const after = currentSectionId();
      const moved = (after && target && after===target);
      log('goToIndex post-check:', {after, moved});

      if(moved){
        // Only autoplay after a successful move. (Remove next line if you want Prev to autoplay too.)
        // if(cause!=='down'){ log('Prev move — no autoplay.'); return; }
        playDialogFor(after, /*force*/false);
      }else{
        log('Navigation not confirmed (blocked or unchanged). No autoplay.');
      }
    }, 0));

    return ret;
  };
  window.goToIndex.__dlgPatched = true;
  log('goToIndex patched.');
  return true;
}

/* ---------------- Keyboard controls for dialog ---------------- */
document.addEventListener('keydown', (e)=>{
  if(!$('#dlg-backdrop')?.classList.contains('show')) return;
  if(e.key==='Enter' || e.key==='ArrowRight'){ e.preventDefault(); onAdvanceInput(); }
  if(e.code==='Space'){ e.preventDefault(); dlg.holdSpeed=true; onAdvanceInput(); }
});
document.addEventListener('keyup', (e)=>{ if(e.code==='Space'){ dlg.holdSpeed=false; }});

/* ---------------- Init ---------------- */
function init(){
  log('INIT');
  ensureHPHud();
  ensureRulesAck();
  installGatePatches();

  // Patch goToIndex once it exists
  const waitPatch = ()=>{
    if(installGoToIndexPatch()){
      // If gate is NOT visible on load, autoplay the currently visible section once
      if(!isGateVisible()){
        const id = currentSectionId();
        if(id && sessionStorage.getItem(`dlg_ran_${id}`)!=='1'){
          log('Init autoplay for first visible section:', id);
          playDialogFor(id, false);
        }
      }
      return;
    }
    setTimeout(waitPatch, 100);
  };
  waitPatch();
  log('INIT done.');
}
if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', init); else init();

})();
